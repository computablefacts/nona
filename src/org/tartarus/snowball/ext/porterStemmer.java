// Generated by Snowball 2.0.0 - https://snowballstem.org/

package org.tartarus.snowball.ext;

import org.tartarus.snowball.Among;

/**
 * This class implements the stemming algorithm defined by a snowball script.
 * <p>
 * Generated by Snowball 2.0.0 - https://snowballstem.org/
 * </p>
 */
@SuppressWarnings("unused")
public class porterStemmer extends org.tartarus.snowball.SnowballStemmer {

  private static final long serialVersionUID = 1L;

  private final static Among a_0[] = {new Among("s", -1, 3), new Among("ies", 0, 2),
      new Among("sses", 0, 1), new Among("ss", 0, -1)};

  private final static Among a_1[] = {new Among("", -1, 3), new Among("bb", 0, 2),
      new Among("dd", 0, 2), new Among("ff", 0, 2), new Among("gg", 0, 2), new Among("bl", 0, 1),
      new Among("mm", 0, 2), new Among("nn", 0, 2), new Among("pp", 0, 2), new Among("rr", 0, 2),
      new Among("at", 0, 1), new Among("tt", 0, 2), new Among("iz", 0, 1)};

  private final static Among a_2[] =
      {new Among("ed", -1, 2), new Among("eed", 0, 1), new Among("ing", -1, 2)};

  private final static Among a_3[] = {new Among("anci", -1, 3), new Among("enci", -1, 2),
      new Among("abli", -1, 4), new Among("eli", -1, 6), new Among("alli", -1, 9),
      new Among("ousli", -1, 11), new Among("entli", -1, 5), new Among("aliti", -1, 9),
      new Among("biliti", -1, 13), new Among("iviti", -1, 12), new Among("tional", -1, 1),
      new Among("ational", 10, 8), new Among("alism", -1, 9), new Among("ation", -1, 8),
      new Among("ization", 13, 7), new Among("izer", -1, 7), new Among("ator", -1, 8),
      new Among("iveness", -1, 12), new Among("fulness", -1, 10), new Among("ousness", -1, 11)};

  private final static Among a_4[] = {new Among("icate", -1, 2), new Among("ative", -1, 3),
      new Among("alize", -1, 1), new Among("iciti", -1, 2), new Among("ical", -1, 2),
      new Among("ful", -1, 3), new Among("ness", -1, 3)};

  private final static Among a_5[] = {new Among("ic", -1, 1), new Among("ance", -1, 1),
      new Among("ence", -1, 1), new Among("able", -1, 1), new Among("ible", -1, 1),
      new Among("ate", -1, 1), new Among("ive", -1, 1), new Among("ize", -1, 1),
      new Among("iti", -1, 1), new Among("al", -1, 1), new Among("ism", -1, 1),
      new Among("ion", -1, 2), new Among("er", -1, 1), new Among("ous", -1, 1),
      new Among("ant", -1, 1), new Among("ent", -1, 1), new Among("ment", 15, 1),
      new Among("ement", 16, 1), new Among("ou", -1, 1)};

  private static final char g_v[] = {17, 65, 16, 1};

  private static final char g_v_WXY[] = {1, 17, 65, 208, 1};

  private boolean B_Y_found;
  private int I_p2;
  private int I_p1;


  private boolean r_shortv() {
    // (, line 19
    if (!(out_grouping_b(g_v_WXY, 89, 121))) {
      return false;
    }
    if (!(in_grouping_b(g_v, 97, 121))) {
      return false;
    }
    if (!(out_grouping_b(g_v, 97, 121))) {
      return false;
    }
    return true;
  }

  private boolean r_R1() {
    if (!(I_p1 <= cursor)) {
      return false;
    }
    return true;
  }

  private boolean r_R2() {
    if (!(I_p2 <= cursor)) {
      return false;
    }
    return true;
  }

  private boolean r_Step_1a() {
    int among_var;
    // (, line 24
    // [, line 25
    ket = cursor;
    // substring, line 25
    among_var = find_among_b(a_0);
    if (among_var == 0) {
      return false;
    }
    // ], line 25
    bra = cursor;
    switch (among_var) {
      case 1:
        // (, line 26
        // <-, line 26
        slice_from("ss");
        break;
      case 2:
        // (, line 27
        // <-, line 27
        slice_from("i");
        break;
      case 3:
        // (, line 29
        // delete, line 29
        slice_del();
        break;
    }
    return true;
  }

  private boolean r_Step_1b() {
    int among_var;
    // (, line 33
    // [, line 34
    ket = cursor;
    // substring, line 34
    among_var = find_among_b(a_2);
    if (among_var == 0) {
      return false;
    }
    // ], line 34
    bra = cursor;
    switch (among_var) {
      case 1:
        // (, line 35
        // call R1, line 35
        if (!r_R1()) {
          return false;
        }
        // <-, line 35
        slice_from("ee");
        break;
      case 2:
        // (, line 37
        // test, line 38
        int v_1 = limit - cursor;
        // gopast, line 38
        golab0: while (true) {
          lab1: {
            if (!(in_grouping_b(g_v, 97, 121))) {
              break lab1;
            }
            break golab0;
          }
          if (cursor <= limit_backward) {
            return false;
          }
          cursor--;
        }
        cursor = limit - v_1;
        // delete, line 38
        slice_del();
        // test, line 39
        int v_3 = limit - cursor;
        // substring, line 39
        among_var = find_among_b(a_1);
        if (among_var == 0) {
          return false;
        }
        cursor = limit - v_3;
        switch (among_var) {
          case 1:
          // (, line 41
          // <+, line 41
          {
            int c = cursor;
            insert(cursor, cursor, "e");
            cursor = c;
          }
            break;
          case 2:
            // (, line 44
            // [, line 44
            ket = cursor;
            // next, line 44
            if (cursor <= limit_backward) {
              return false;
            }
            cursor--;
            // ], line 44
            bra = cursor;
            // delete, line 44
            slice_del();
            break;
          case 3:
            // (, line 45
            // atmark, line 45
            if (cursor != I_p1) {
              return false;
            }
            // test, line 45
            int v_4 = limit - cursor;
            // call shortv, line 45
            if (!r_shortv()) {
              return false;
            }
            cursor = limit - v_4;
          // <+, line 45
          {
            int c = cursor;
            insert(cursor, cursor, "e");
            cursor = c;
          }
            break;
        }
        break;
    }
    return true;
  }

  private boolean r_Step_1c() {
    // (, line 51
    // [, line 52
    ket = cursor;
    // or, line 52
    lab0: {
      int v_1 = limit - cursor;
      lab1: {
        // literal, line 52
        if (!(eq_s_b("y"))) {
          break lab1;
        }
        break lab0;
      }
      cursor = limit - v_1;
      // literal, line 52
      if (!(eq_s_b("Y"))) {
        return false;
      }
    }
    // ], line 52
    bra = cursor;
    // gopast, line 53
    golab2: while (true) {
      lab3: {
        if (!(in_grouping_b(g_v, 97, 121))) {
          break lab3;
        }
        break golab2;
      }
      if (cursor <= limit_backward) {
        return false;
      }
      cursor--;
    }
    // <-, line 54
    slice_from("i");
    return true;
  }

  private boolean r_Step_2() {
    int among_var;
    // (, line 57
    // [, line 58
    ket = cursor;
    // substring, line 58
    among_var = find_among_b(a_3);
    if (among_var == 0) {
      return false;
    }
    // ], line 58
    bra = cursor;
    // call R1, line 58
    if (!r_R1()) {
      return false;
    }
    switch (among_var) {
      case 1:
        // (, line 59
        // <-, line 59
        slice_from("tion");
        break;
      case 2:
        // (, line 60
        // <-, line 60
        slice_from("ence");
        break;
      case 3:
        // (, line 61
        // <-, line 61
        slice_from("ance");
        break;
      case 4:
        // (, line 62
        // <-, line 62
        slice_from("able");
        break;
      case 5:
        // (, line 63
        // <-, line 63
        slice_from("ent");
        break;
      case 6:
        // (, line 64
        // <-, line 64
        slice_from("e");
        break;
      case 7:
        // (, line 66
        // <-, line 66
        slice_from("ize");
        break;
      case 8:
        // (, line 68
        // <-, line 68
        slice_from("ate");
        break;
      case 9:
        // (, line 69
        // <-, line 69
        slice_from("al");
        break;
      case 10:
        // (, line 72
        // <-, line 72
        slice_from("ful");
        break;
      case 11:
        // (, line 74
        // <-, line 74
        slice_from("ous");
        break;
      case 12:
        // (, line 76
        // <-, line 76
        slice_from("ive");
        break;
      case 13:
        // (, line 77
        // <-, line 77
        slice_from("ble");
        break;
    }
    return true;
  }

  private boolean r_Step_3() {
    int among_var;
    // (, line 81
    // [, line 82
    ket = cursor;
    // substring, line 82
    among_var = find_among_b(a_4);
    if (among_var == 0) {
      return false;
    }
    // ], line 82
    bra = cursor;
    // call R1, line 82
    if (!r_R1()) {
      return false;
    }
    switch (among_var) {
      case 1:
        // (, line 83
        // <-, line 83
        slice_from("al");
        break;
      case 2:
        // (, line 85
        // <-, line 85
        slice_from("ic");
        break;
      case 3:
        // (, line 87
        // delete, line 87
        slice_del();
        break;
    }
    return true;
  }

  private boolean r_Step_4() {
    int among_var;
    // (, line 91
    // [, line 92
    ket = cursor;
    // substring, line 92
    among_var = find_among_b(a_5);
    if (among_var == 0) {
      return false;
    }
    // ], line 92
    bra = cursor;
    // call R2, line 92
    if (!r_R2()) {
      return false;
    }
    switch (among_var) {
      case 1:
        // (, line 95
        // delete, line 95
        slice_del();
        break;
      case 2:
        // (, line 96
        // or, line 96
        lab0: {
          int v_1 = limit - cursor;
          lab1: {
            // literal, line 96
            if (!(eq_s_b("s"))) {
              break lab1;
            }
            break lab0;
          }
          cursor = limit - v_1;
          // literal, line 96
          if (!(eq_s_b("t"))) {
            return false;
          }
        }
        // delete, line 96
        slice_del();
        break;
    }
    return true;
  }

  private boolean r_Step_5a() {
    // (, line 100
    // [, line 101
    ket = cursor;
    // literal, line 101
    if (!(eq_s_b("e"))) {
      return false;
    }
    // ], line 101
    bra = cursor;
    // or, line 102
    lab0: {
      int v_1 = limit - cursor;
      lab1: {
        // call R2, line 102
        if (!r_R2()) {
          break lab1;
        }
        break lab0;
      }
      cursor = limit - v_1;
      // (, line 102
      // call R1, line 102
      if (!r_R1()) {
        return false;
      }
      // not, line 102
      {
        int v_2 = limit - cursor;
        lab2: {
          // call shortv, line 102
          if (!r_shortv()) {
            break lab2;
          }
          return false;
        }
        cursor = limit - v_2;
      }
    }
    // delete, line 103
    slice_del();
    return true;
  }

  private boolean r_Step_5b() {
    // (, line 106
    // [, line 107
    ket = cursor;
    // literal, line 107
    if (!(eq_s_b("l"))) {
      return false;
    }
    // ], line 107
    bra = cursor;
    // call R2, line 108
    if (!r_R2()) {
      return false;
    }
    // literal, line 108
    if (!(eq_s_b("l"))) {
      return false;
    }
    // delete, line 109
    slice_del();
    return true;
  }

  public boolean stem() {
    // (, line 113
    // unset Y_found, line 115
    B_Y_found = false;
    // do, line 116
    int v_1 = cursor;
    lab0: {
      // (, line 116
      // [, line 116
      bra = cursor;
      // literal, line 116
      if (!(eq_s("y"))) {
        break lab0;
      }
      // ], line 116
      ket = cursor;
      // <-, line 116
      slice_from("Y");
      // set Y_found, line 116
      B_Y_found = true;
    }
    cursor = v_1;
    // do, line 117
    int v_2 = cursor;
    lab1: {
      // repeat, line 117
      while (true) {
        int v_3 = cursor;
        lab2: {
          // (, line 117
          // goto, line 117
          golab3: while (true) {
            int v_4 = cursor;
            lab4: {
              // (, line 117
              if (!(in_grouping(g_v, 97, 121))) {
                break lab4;
              }
              // [, line 117
              bra = cursor;
              // literal, line 117
              if (!(eq_s("y"))) {
                break lab4;
              }
              // ], line 117
              ket = cursor;
              cursor = v_4;
              break golab3;
            }
            cursor = v_4;
            if (cursor >= limit) {
              break lab2;
            }
            cursor++;
          }
          // <-, line 117
          slice_from("Y");
          // set Y_found, line 117
          B_Y_found = true;
          continue;
        }
        cursor = v_3;
        break;
      }
    }
    cursor = v_2;
    I_p1 = limit;
    I_p2 = limit;
    // do, line 121
    int v_5 = cursor;
    lab5: {
      // (, line 121
      // gopast, line 122
      golab6: while (true) {
        lab7: {
          if (!(in_grouping(g_v, 97, 121))) {
            break lab7;
          }
          break golab6;
        }
        if (cursor >= limit) {
          break lab5;
        }
        cursor++;
      }
      // gopast, line 122
      golab8: while (true) {
        lab9: {
          if (!(out_grouping(g_v, 97, 121))) {
            break lab9;
          }
          break golab8;
        }
        if (cursor >= limit) {
          break lab5;
        }
        cursor++;
      }
      // setmark p1, line 122
      I_p1 = cursor;
      // gopast, line 123
      golab10: while (true) {
        lab11: {
          if (!(in_grouping(g_v, 97, 121))) {
            break lab11;
          }
          break golab10;
        }
        if (cursor >= limit) {
          break lab5;
        }
        cursor++;
      }
      // gopast, line 123
      golab12: while (true) {
        lab13: {
          if (!(out_grouping(g_v, 97, 121))) {
            break lab13;
          }
          break golab12;
        }
        if (cursor >= limit) {
          break lab5;
        }
        cursor++;
      }
      // setmark p2, line 123
      I_p2 = cursor;
    }
    cursor = v_5;
    // backwards, line 126
    limit_backward = cursor;
    cursor = limit;
    // (, line 126
    // do, line 127
    int v_10 = limit - cursor;
    // call Step_1a, line 127
    r_Step_1a();
    cursor = limit - v_10;
    // do, line 128
    int v_11 = limit - cursor;
    // call Step_1b, line 128
    r_Step_1b();
    cursor = limit - v_11;
    // do, line 129
    int v_12 = limit - cursor;
    // call Step_1c, line 129
    r_Step_1c();
    cursor = limit - v_12;
    // do, line 130
    int v_13 = limit - cursor;
    // call Step_2, line 130
    r_Step_2();
    cursor = limit - v_13;
    // do, line 131
    int v_14 = limit - cursor;
    // call Step_3, line 131
    r_Step_3();
    cursor = limit - v_14;
    // do, line 132
    int v_15 = limit - cursor;
    // call Step_4, line 132
    r_Step_4();
    cursor = limit - v_15;
    // do, line 133
    int v_16 = limit - cursor;
    // call Step_5a, line 133
    r_Step_5a();
    cursor = limit - v_16;
    // do, line 134
    int v_17 = limit - cursor;
    // call Step_5b, line 134
    r_Step_5b();
    cursor = limit - v_17;
    cursor = limit_backward;
    // do, line 137
    int v_18 = cursor;
    lab14: {
      // (, line 137
      // Boolean test Y_found, line 137
      if (!(B_Y_found)) {
        break lab14;
      }
      // repeat, line 137
      while (true) {
        int v_19 = cursor;
        lab15: {
          // (, line 137
          // goto, line 137
          golab16: while (true) {
            int v_20 = cursor;
            lab17: {
              // (, line 137
              // [, line 137
              bra = cursor;
              // literal, line 137
              if (!(eq_s("Y"))) {
                break lab17;
              }
              // ], line 137
              ket = cursor;
              cursor = v_20;
              break golab16;
            }
            cursor = v_20;
            if (cursor >= limit) {
              break lab15;
            }
            cursor++;
          }
          // <-, line 137
          slice_from("y");
          continue;
        }
        cursor = v_19;
        break;
      }
    }
    cursor = v_18;
    return true;
  }

  @Override
  public boolean equals(Object o) {
    return o instanceof porterStemmer;
  }

  @Override
  public int hashCode() {
    return porterStemmer.class.getName().hashCode();
  }



}

